<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MirrorMaker - Trading Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #0a0e27 0%, #1a1a2e 25%, #16213e 50%, #0f3460 75%, #1a1a2e 100%);
      color: #e1e8ed;
      padding: 20px;
      min-height: 100vh;
      position: relative;
    }

    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background:
        radial-gradient(circle at 20% 50%, rgba(0, 212, 255, 0.08) 0%, transparent 50%),
        radial-gradient(circle at 80% 80%, rgba(102, 126, 234, 0.08) 0%, transparent 50%),
        radial-gradient(circle at 40% 20%, rgba(118, 75, 162, 0.06) 0%, transparent 50%);
      pointer-events: none;
      z-index: 0;
    }

    body > * {
      position: relative;
      z-index: 1;
    }

    .header {
      text-align: center;
      margin-bottom: 30px;
    }

    .nav-links {
      text-align: center;
      margin-bottom: 20px;
    }

    .nav-links a {
      color: #00d4ff;
      text-decoration: none;
      padding: 8px 16px;
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(0, 212, 255, 0.3);
      border-radius: 8px;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }

    .nav-links a:hover {
      background: linear-gradient(135deg, rgba(0, 212, 255, 0.2) 0%, rgba(102, 126, 234, 0.2) 100%);
      border-color: rgba(0, 212, 255, 0.5);
      color: #fff;
      transform: translateY(-2px);
      box-shadow:
        0 6px 20px rgba(0, 212, 255, 0.3),
        0 0 15px rgba(0, 212, 255, 0.1);
    }

    h1 {
      font-size: clamp(1.8rem, 5vw, 2.5rem);
      margin-bottom: 10px;
      background: linear-gradient(135deg, #00d4ff 0%, #667eea 50%, #a855f7 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      filter: drop-shadow(0 0 20px rgba(0, 212, 255, 0.3));
    }

    h1 a {
      text-decoration: none;
      background: linear-gradient(135deg, #00d4ff 0%, #667eea 50%, #a855f7 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    h1 a:hover {
      opacity: 0.8;
    }

    .subtitle {
      color: #8899a6;
      font-size: clamp(0.95rem, 2.5vw, 1.1rem);
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 30px;
    }

    .stat-card {
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      padding: 20px;
      transition: all 0.3s ease;
      box-shadow:
        0 8px 32px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    .stat-card:hover {
      transform: translateY(-5px) scale(1.02);
      border-color: rgba(0, 212, 255, 0.5);
      background: rgba(255, 255, 255, 0.08);
      box-shadow:
        0 12px 40px rgba(0, 212, 255, 0.2),
        0 0 20px rgba(0, 212, 255, 0.1),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
    }

    .stat-label {
      font-size: 0.85em;
      color: #8899a6;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .stat-value {
      font-size: clamp(1.3rem, 4vw, 1.8rem);
      font-weight: bold;
      color: #e1e8ed;
    }

    .stat-value.positive {
      color: #17bf63;
    }

    .stat-value.negative {
      color: #e0245e;
    }

    .chart-container {
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow:
        0 8px 32px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      min-width: 0;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      transition: all 0.3s ease;
    }

    .chart-container:hover {
      border-color: rgba(0, 212, 255, 0.3);
      box-shadow:
        0 12px 40px rgba(0, 0, 0, 0.4),
        0 0 20px rgba(0, 212, 255, 0.1),
        inset 0 1px 0 rgba(255, 255, 255, 0.15);
    }

    .chart-container > div {
      min-width: 300px;
    }

    .chart-container canvas {
      min-height: 300px;
      max-height: 400px;
    }

    .chart-title {
      font-size: clamp(1rem, 3vw, 1.3rem);
      margin-bottom: 15px;
      color: #e1e8ed;
    }

    .loading {
      text-align: center;
      padding: 50px;
      font-size: 1.5em;
      color: #8899a6;
    }

    .error {
      background: rgba(224, 36, 94, 0.1);
      backdrop-filter: blur(15px);
      -webkit-backdrop-filter: blur(15px);
      border: 1px solid rgba(224, 36, 94, 0.3);
      color: #ff6b9d;
      padding: 20px;
      border-radius: 12px;
      margin-bottom: 20px;
      box-shadow:
        0 8px 24px rgba(224, 36, 94, 0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    .controls {
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 20px;
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      align-items: center;
      box-shadow:
        0 8px 32px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .control-group label {
      font-size: 0.85em;
      color: #8899a6;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    input, select, button {
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: #e1e8ed;
      padding: 10px 15px;
      border-radius: 8px;
      font-size: 1em;
      transition: all 0.3s ease;
    }

    input:hover, select:hover {
      background: rgba(255, 255, 255, 0.08);
      border-color: rgba(0, 212, 255, 0.3);
    }

    button {
      background: linear-gradient(135deg, #00d4ff 0%, #667eea 50%, #a855f7 100%);
      border: none;
      cursor: pointer;
      font-weight: bold;
      box-shadow:
        0 4px 16px rgba(0, 212, 255, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow:
        0 6px 24px rgba(0, 212, 255, 0.4),
        0 0 20px rgba(0, 212, 255, 0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.3);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .wallet-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 5px;
    }

    .tracked-wallet {
      background: linear-gradient(135deg, #00d4ff 0%, #667eea 100%);
      box-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
    }

    .user-wallet {
      background: linear-gradient(135deg, #17bf63 0%, #00d4a0 100%);
      box-shadow: 0 0 10px rgba(23, 191, 99, 0.5);
    }

    .charts-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }

    .health-overview {
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow:
        0 8px 32px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    .health-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      flex-wrap: wrap;
      gap: 10px;
    }

    .health-status-badge {
      padding: 8px 16px;
      border-radius: 20px;
      font-weight: bold;
      font-size: 0.9em;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .health-status-badge.healthy {
      background: linear-gradient(135deg, #17bf63 0%, #00d4a0 100%);
      box-shadow: 0 0 15px rgba(23, 191, 99, 0.5);
    }

    .health-status-badge.degraded {
      background: linear-gradient(135deg, #ffad1f 0%, #ff8c00 100%);
      box-shadow: 0 0 15px rgba(255, 173, 31, 0.5);
    }

    .health-status-badge.unhealthy {
      background: linear-gradient(135deg, #e0245e 0%, #ff0044 100%);
      box-shadow: 0 0 15px rgba(224, 36, 94, 0.5);
    }

    .health-metrics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 12px;
      margin-top: 15px;
    }

    .health-metric {
      padding: 12px;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 10px;
    }

    .health-metric-label {
      font-size: 0.75em;
      color: #8899a6;
      text-transform: uppercase;
      letter-spacing: 0.3px;
      margin-bottom: 5px;
    }

    .health-metric-value {
      font-size: 1.1em;
      font-weight: bold;
      color: #e1e8ed;
    }

    .health-metric-value.healthy {
      color: #17bf63;
    }

    .health-metric-value.unhealthy {
      color: #e0245e;
    }

    /* Small phones - portrait */
    @media (max-width: 480px) {
      body {
        padding: 10px;
        font-size: 16px;
      }

      .nav-links a {
        display: block;
        margin: 10px 0;
        padding: 12px 16px;
        min-height: 48px;
      }

      .stats-grid {
        grid-template-columns: 1fr;
        gap: 10px;
      }

      .stat-card {
        padding: 15px;
      }

      .charts-row {
        grid-template-columns: 1fr;
        gap: 15px;
      }

      .chart-container {
        padding: 15px;
      }

      .controls {
        flex-direction: column;
        align-items: stretch;
        padding: 15px;
      }

      .control-group {
        width: 100%;
      }

      select, button {
        width: 100%;
        padding: 14px 16px;
        font-size: 16px;
        min-height: 48px;
      }
    }

    /* Mobile and small tablets - portrait */
    @media (min-width: 481px) and (max-width: 768px) {
      body {
        padding: 15px;
      }

      .stats-grid {
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 12px;
      }

      .charts-row {
        grid-template-columns: 1fr;
        gap: 15px;
      }

      .chart-container {
        padding: 18px;
      }

      select, button {
        padding: 12px 16px;
        min-height: 44px;
      }
    }

    /* Tablets/iPad - portrait and landscape */
    @media (min-width: 769px) and (max-width: 1024px) {
      body {
        padding: 20px;
      }

      .stats-grid {
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
      }

      .charts-row {
        grid-template-columns: 1fr;
        gap: 18px;
      }

      .chart-container {
        padding: 20px;
      }
    }

    /* Large tablets and small desktops */
    @media (min-width: 1025px) and (max-width: 1440px) {
      .charts-row {
        grid-template-columns: 1fr 1fr;
      }
    }

    /* Landscape orientation - mobile devices */
    @media (max-width: 768px) and (orientation: landscape) {
      .charts-row {
        grid-template-columns: repeat(2, 1fr);
      }
    }
  </style>
</head>
<body>
  <div class="header">
    <h1><a href="/dashboard.html">Copy Trading Dashboard</a></h1>
    <p class="subtitle">Tracked vs User wallet comparison</p>
  </div>

  <div class="nav-links">
    <a href="/dashboard.html">View Main Dashboard</a>
  </div>

  <div id="loading" class="loading">Loading snapshot data...</div>
  <div id="error" class="error" style="display: none;"></div>

  <div id="dashboard" style="display: none;">
    <div class="stats-grid">
      <div class="stat-card">
        <div class="stat-label">
          <span class="wallet-indicator tracked-wallet"></span>Tracked Realized Balance
        </div>
        <div class="stat-value" id="tracked-balance-without-pnl">$0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">
          <span class="wallet-indicator tracked-wallet"></span>Tracked Balance
        </div>
        <div class="stat-value" id="tracked-balance">$0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">
          <span class="wallet-indicator user-wallet"></span>User Realized Balance
        </div>
        <div class="stat-value" id="user-balance-without-pnl">$0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">
          <span class="wallet-indicator user-wallet"></span>User Balance
        </div>
        <div class="stat-value" id="user-balance">$0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Balance Ratio</div>
        <div class="stat-value" id="balance-ratio">0.00</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">
          <span class="wallet-indicator tracked-wallet"></span>Tracked PNL
        </div>
        <div class="stat-value" id="tracked-pnl">$0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">
          <span class="wallet-indicator user-wallet"></span>User PNL
        </div>
        <div class="stat-value" id="user-pnl">$0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">
          <span class="wallet-indicator tracked-wallet"></span>Tracked Daily PNL
        </div>
        <div class="stat-value" id="tracked-daily-pnl">$0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">
          <span class="wallet-indicator user-wallet"></span>User Daily PNL
        </div>
        <div class="stat-value" id="user-daily-pnl">$0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Total Snapshots</div>
        <div class="stat-value" id="snapshot-count">0</div>
      </div>
    </div>

    <div class="health-overview">
      <div class="health-header">
        <h2 style="margin: 0; font-size: 1.2rem;">System Health</h2>
        <span id="health-status-badge" class="health-status-badge healthy">Healthy</span>
      </div>

      <div class="health-metrics-grid">
        <div class="health-metric">
          <div class="health-metric-label">Uptime</div>
          <div class="health-metric-value" id="health-uptime">-</div>
        </div>
        <div class="health-metric">
          <div class="health-metric-label">Order Success</div>
          <div class="health-metric-value" id="health-order-success">-</div>
        </div>
        <div class="health-metric">
          <div class="health-metric-label">Fill Processing</div>
          <div class="health-metric-value" id="health-fill-processing">-</div>
        </div>
        <div class="health-metric">
          <div class="health-metric-label">WebSocket</div>
          <div class="health-metric-value" id="health-websocket">-</div>
        </div>
        <div class="health-metric">
          <div class="health-metric-label">API Status</div>
          <div class="health-metric-value" id="health-api">-</div>
        </div>
        <div class="health-metric">
          <div class="health-metric-label">Consecutive Errors</div>
          <div class="health-metric-value" id="health-errors">-</div>
        </div>
      </div>
    </div>

    <div class="chart-container">
      <div class="chart-title">Health Incidents Timeline</div>
      <canvas id="incidents-chart"></canvas>
    </div>

    <div class="controls">
      <div class="control-group">
        <label>Viewing Data For:</label>
        <span id="selected-date-display" style="font-weight: bold; font-size: 1.1em;">Today</span>
      </div>
    </div>

    <div class="charts-row">
      <div class="chart-container">
        <div class="chart-title">
          <span class="wallet-indicator tracked-wallet"></span>Tracked Wallet Balance
        </div>
        <canvas id="tracked-balance-chart"></canvas>
      </div>
      <div class="chart-container">
        <div class="chart-title">
          <span class="wallet-indicator user-wallet"></span>User Wallet Balance
        </div>
        <canvas id="user-balance-chart"></canvas>
      </div>
    </div>

    <div class="charts-row">
      <div class="chart-container">
        <div class="chart-title">
          <span class="wallet-indicator tracked-wallet"></span>Tracked Wallet PNL
        </div>
        <canvas id="tracked-pnl-chart"></canvas>
      </div>
      <div class="chart-container">
        <div class="chart-title">
          <span class="wallet-indicator user-wallet"></span>User Wallet PNL
        </div>
        <canvas id="user-pnl-chart"></canvas>
      </div>
    </div>

    <div class="charts-row">
      <div class="chart-container">
        <div class="chart-title">
          <span class="wallet-indicator tracked-wallet"></span>Tracked Position Sizes
        </div>
        <canvas id="tracked-positions-chart"></canvas>
      </div>
      <div class="chart-container">
        <div class="chart-title">
          <span class="wallet-indicator user-wallet"></span>User Position Sizes
        </div>
        <canvas id="user-positions-chart"></canvas>
      </div>
    </div>

    <div class="chart-container">
      <div class="chart-title">Drawdown Analysis</div>
      <canvas id="drawdown-chart"></canvas>
    </div>

    <div class="chart-container">
      <div class="chart-title">Entry Price Difference % (User vs Tracked)</div>
      <canvas id="entry-diff-chart"></canvas>
    </div>

    <div class="chart-container">
      <div class="chart-title">Risk Metrics</div>
      <canvas id="risk-chart"></canvas>
    </div>
  </div>

  <script>
    let filteredSnapshots = [];
    let selectedDate = new Date().toISOString().split('T')[0];

    // Consistent color palette for symbols across all charts
    const SYMBOL_COLORS = [
      '#667eea', // purple
      '#17bf63', // green
      '#e0245e', // red
      '#ffad1f', // orange
      '#1da1f2', // blue
      '#f91880', // pink
      '#794bc4', // deep purple
      '#00ba7c', // teal
      '#ff6b6b', // light red
      '#4ecdc4', // cyan
      '#95e1d3', // mint
      '#f38181'  // coral
    ];

    // Hash function to consistently map symbol names to colors
    function getSymbolColor(symbol) {
      let hash = 0;
      for (let i = 0; i < symbol.length; i++) {
        hash = symbol.charCodeAt(i) + ((hash << 5) - hash);
      }
      const index = Math.abs(hash) % SYMBOL_COLORS.length;
      return SYMBOL_COLORS[index];
    }

    // Store chart instances for updates
    let chartInstances = {};

    // Chart.js dark theme configuration
    function getChartConfig(type = 'line', options = {}) {
      return {
        type,
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            mode: 'index',
            intersect: false
          },
          plugins: {
            legend: {
              labels: {
                color: '#e1e8ed',
                font: { size: 12 }
              },
              ...options.legend
            },
            tooltip: {
              backgroundColor: '#192734',
              titleColor: '#e1e8ed',
              bodyColor: '#8899a6',
              borderColor: '#38444d',
              borderWidth: 1
            }
          },
          scales: {
            x: {
              ticks: { color: '#8899a6', font: { size: 11 } },
              grid: { color: '#38444d', display: true },
              type: 'time',
              time: { tooltipFormat: 'MMM d, HH:mm' }
            },
            y: {
              ticks: { color: '#8899a6', font: { size: 11 } },
              grid: { color: '#38444d', display: true },
              ...options.yScale
            },
            ...(options.y2Scale && {
              y2: {
                position: 'right',
                ticks: { color: '#8899a6', font: { size: 11 } },
                grid: { display: false },
                ...options.y2Scale
              }
            })
          },
          ...options.extra
        }
      };
    }

    async function fetchSnapshots(date = null) {
      try {
        const targetDate = date || selectedDate;
        const response = await fetch(`/api/snapshots?date=${targetDate}`);
        const data = await response.json();

        if (!response.ok) {
          throw new Error(data.error || 'Failed to fetch snapshots');
        }

        filteredSnapshots = data.snapshots;

        if (filteredSnapshots.length === 0) {
          showError(`No snapshot data available for ${targetDate}. Run the monitor to start collecting data.`);
          return;
        }

        updateSelectedDateDisplay(targetDate);
        renderDashboard();

      } catch (error) {
        showError(`Error loading data: ${error.message}`);
      }
    }

    function updateSelectedDateDisplay(dateStr) {
      const displayEl = document.getElementById('selected-date-display');
      const today = new Date().toISOString().split('T')[0];

      if (dateStr === today) {
        displayEl.textContent = 'Today';
      } else {
        const date = new Date(dateStr);
        displayEl.textContent = date.toLocaleDateString('en-US', {
          month: 'short',
          day: 'numeric',
          year: 'numeric'
        });
      }
    }

    function renderDashboard() {
      if (filteredSnapshots.length === 0) {
        showError('No data available for selected time range');
        return;
      }

      document.getElementById('loading').style.display = 'none';
      document.getElementById('error').style.display = 'none';
      document.getElementById('dashboard').style.display = 'block';

      updateStats();
      renderBalanceChart();
      renderPnlChart();
      renderPositionSizeCharts();
      renderEntryDiffChart();
      renderDrawdownChart();
      renderRiskChart();
    }

    function updateStats() {
      const latest = filteredSnapshots[filteredSnapshots.length - 1];

      document.getElementById('tracked-balance').textContent = `$${latest.tracked.accountValue.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
      document.getElementById('user-balance').textContent = `$${latest.user.accountValue.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;

      const trackedBalanceWithoutPnl = latest.tracked.accountValue - (latest.tracked.totalUnrealizedPnl || 0);
      const userBalanceWithoutPnl = latest.user.accountValue - (latest.user.totalUnrealizedPnl || 0);
      document.getElementById('tracked-balance-without-pnl').textContent = `$${trackedBalanceWithoutPnl.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
      document.getElementById('user-balance-without-pnl').textContent = `$${userBalanceWithoutPnl.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;

      document.getElementById('balance-ratio').textContent = latest.balanceRatio.toFixed(4);

      const trackedPnl = latest.tracked.totalUnrealizedPnl;
      const userPnl = latest.user.totalUnrealizedPnl;

      const trackedPnlEl = document.getElementById('tracked-pnl');
      const userPnlEl = document.getElementById('user-pnl');

      trackedPnlEl.textContent = `$${trackedPnl.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
      userPnlEl.textContent = `$${userPnl.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;

      trackedPnlEl.className = `stat-value ${trackedPnl >= 0 ? 'positive' : 'negative'}`;
      userPnlEl.className = `stat-value ${userPnl >= 0 ? 'positive' : 'negative'}`;

      const dailyPnl = calculateDailyPnl();

      const trackedDailyPnlEl = document.getElementById('tracked-daily-pnl');
      const userDailyPnlEl = document.getElementById('user-daily-pnl');

      trackedDailyPnlEl.textContent = `$${dailyPnl.tracked.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
      userDailyPnlEl.textContent = `$${dailyPnl.user.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;

      trackedDailyPnlEl.className = `stat-value ${dailyPnl.tracked >= 0 ? 'positive' : 'negative'}`;
      userDailyPnlEl.className = `stat-value ${dailyPnl.user >= 0 ? 'positive' : 'negative'}`;

      document.getElementById('snapshot-count').textContent = filteredSnapshots.length.toLocaleString();
    }

    function calculateDailyPnl() {
      if (filteredSnapshots.length === 0) {
        return { tracked: 0, user: 0 };
      }

      const latest = filteredSnapshots[filteredSnapshots.length - 1];
      const now = new Date();
      const startOfDay = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();

      const firstSnapshotOfDay = filteredSnapshots.find(s => s.timestamp >= startOfDay);

      if (!firstSnapshotOfDay) {
        return { tracked: 0, user: 0 };
      }

      const trackedDailyPnl = latest.tracked.accountValue - firstSnapshotOfDay.tracked.accountValue;
      const userDailyPnl = latest.user.accountValue - firstSnapshotOfDay.user.accountValue;

      return {
        tracked: trackedDailyPnl,
        user: userDailyPnl
      };
    }

    function renderBalanceChart() {
      const dates = filteredSnapshots.map(s => new Date(s.timestamp));

      // Tracked Balance Chart
      if (chartInstances['tracked-balance-chart']) chartInstances['tracked-balance-chart'].destroy();
      const trackedCtx = document.getElementById('tracked-balance-chart').getContext('2d');
      chartInstances['tracked-balance-chart'] = new Chart(trackedCtx, {
        ...getChartConfig('line', {
          legend: { display: false },
          yScale: {
            title: { display: true, text: 'Account Value (USD)', color: '#8899a6' },
            ticks: {
              color: '#8899a6',
              font: { size: 11 },
              callback: function(value) {
                return '$' + value.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
              }
            }
          }
        }),
        data: {
          labels: dates,
          datasets: [{
            label: 'Tracked Balance',
            data: filteredSnapshots.map(s => s.tracked.accountValue),
            borderColor: '#667eea',
            backgroundColor: 'rgba(102, 126, 234, 0.1)',
            fill: true,
            borderWidth: 3,
            tension: 0.1,
            pointRadius: 0
          }]
        }
      });

      // User Balance Chart
      if (chartInstances['user-balance-chart']) chartInstances['user-balance-chart'].destroy();
      const userCtx = document.getElementById('user-balance-chart').getContext('2d');
      chartInstances['user-balance-chart'] = new Chart(userCtx, {
        ...getChartConfig('line', {
          legend: { display: false },
          yScale: {
            title: { display: true, text: 'Account Value (USD)', color: '#8899a6' },
            ticks: {
              color: '#8899a6',
              font: { size: 11 },
              callback: function(value) {
                return '$' + value.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
              }
            }
          }
        }),
        data: {
          labels: dates,
          datasets: [{
            label: 'User Balance',
            data: filteredSnapshots.map(s => s.user.accountValue),
            borderColor: '#17bf63',
            backgroundColor: 'rgba(23, 191, 99, 0.1)',
            fill: true,
            borderWidth: 3,
            tension: 0.1,
            pointRadius: 0
          }]
        }
      });
    }

    function renderPnlChart() {
      const dates = filteredSnapshots.map(s => new Date(s.timestamp));

      // Tracked PNL Chart
      if (chartInstances['tracked-pnl-chart']) chartInstances['tracked-pnl-chart'].destroy();
      const trackedCtx = document.getElementById('tracked-pnl-chart').getContext('2d');
      chartInstances['tracked-pnl-chart'] = new Chart(trackedCtx, {
        ...getChartConfig('line', {
          legend: { display: false },
          yScale: {
            title: { display: true, text: 'Unrealized PNL (USD)', color: '#8899a6' },
            ticks: {
              color: '#8899a6',
              font: { size: 11 },
              callback: function(value) {
                return '$' + value.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
              }
            }
          }
        }),
        data: {
          labels: dates,
          datasets: [{
            label: 'Tracked PNL',
            data: filteredSnapshots.map(s => s.tracked.totalUnrealizedPnl),
            borderColor: '#667eea',
            backgroundColor: 'rgba(102, 126, 234, 0.3)',
            fill: true,
            borderWidth: 3,
            tension: 0.1,
            pointRadius: 0
          }]
        }
      });

      // User PNL Chart
      if (chartInstances['user-pnl-chart']) chartInstances['user-pnl-chart'].destroy();
      const userCtx = document.getElementById('user-pnl-chart').getContext('2d');
      chartInstances['user-pnl-chart'] = new Chart(userCtx, {
        ...getChartConfig('line', {
          legend: { display: false },
          yScale: {
            title: { display: true, text: 'Unrealized PNL (USD)', color: '#8899a6' },
            ticks: {
              color: '#8899a6',
              font: { size: 11 },
              callback: function(value) {
                return '$' + value.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
              }
            }
          }
        }),
        data: {
          labels: dates,
          datasets: [{
            label: 'User PNL',
            data: filteredSnapshots.map(s => s.user.totalUnrealizedPnl),
            borderColor: '#17bf63',
            backgroundColor: 'rgba(23, 191, 99, 0.3)',
            fill: true,
            borderWidth: 3,
            tension: 0.1,
            pointRadius: 0
          }]
        }
      });
    }

    function renderPositionSizeCharts() {
      const trackedCoinData = {};
      const userCoinData = {};

      filteredSnapshots.forEach(snapshot => {
        const timestamp = new Date(snapshot.timestamp);

        snapshot.tracked.positions.forEach(pos => {
          if (!trackedCoinData[pos.coin]) {
            trackedCoinData[pos.coin] = { x: [], y: [] };
          }
          trackedCoinData[pos.coin].x.push(timestamp);
          trackedCoinData[pos.coin].y.push(pos.notionalValue);
        });

        snapshot.user.positions.forEach(pos => {
          if (!userCoinData[pos.coin]) {
            userCoinData[pos.coin] = { x: [], y: [] };
          }
          userCoinData[pos.coin].x.push(timestamp);
          userCoinData[pos.coin].y.push(pos.notionalValue);
        });
      });

      // Tracked Positions Chart
      const trackedDatasets = Object.entries(trackedCoinData).map(([coin, data]) => ({
        label: coin,
        data: data.x.map((x, i) => ({ x, y: data.y[i] })),
        borderColor: getSymbolColor(coin),
        backgroundColor: getSymbolColor(coin) + '20',
        borderWidth: 2,
        tension: 0.1,
        fill: false,
        pointRadius: 0
      }));

      if (chartInstances['tracked-positions-chart']) chartInstances['tracked-positions-chart'].destroy();
      const trackedCtx = document.getElementById('tracked-positions-chart').getContext('2d');
      chartInstances['tracked-positions-chart'] = new Chart(trackedCtx, {
        ...getChartConfig('line', {
          legend: { position: 'right' },
          yScale: {
            title: { display: true, text: 'Position Size (USD)', color: '#8899a6' },
            ticks: {
              color: '#8899a6',
              font: { size: 11 },
              callback: function(value) {
                return '$' + value.toLocaleString(undefined, {minimumFractionDigits: 0, maximumFractionDigits: 0});
              }
            }
          }
        }),
        data: { datasets: trackedDatasets }
      });

      // User Positions Chart
      const userDatasets = Object.entries(userCoinData).map(([coin, data]) => ({
        label: coin,
        data: data.x.map((x, i) => ({ x, y: data.y[i] })),
        borderColor: getSymbolColor(coin),
        backgroundColor: getSymbolColor(coin) + '20',
        borderWidth: 2,
        tension: 0.1,
        fill: false,
        pointRadius: 0
      }));

      if (chartInstances['user-positions-chart']) chartInstances['user-positions-chart'].destroy();
      const userCtx = document.getElementById('user-positions-chart').getContext('2d');
      chartInstances['user-positions-chart'] = new Chart(userCtx, {
        ...getChartConfig('line', {
          legend: { position: 'right' },
          yScale: {
            title: { display: true, text: 'Position Size (USD)', color: '#8899a6' },
            ticks: {
              color: '#8899a6',
              font: { size: 11 },
              callback: function(value) {
                return '$' + value.toLocaleString(undefined, {minimumFractionDigits: 0, maximumFractionDigits: 0});
              }
            }
          }
        }),
        data: { datasets: userDatasets }
      });
    }

    function renderDrawdownChart() {
      const dates = filteredSnapshots.map(s => new Date(s.timestamp));
      const trackedDrawdown = calculateDrawdown(filteredSnapshots.map(s => s.tracked.accountValue));
      const userDrawdown = calculateDrawdown(filteredSnapshots.map(s => s.user.accountValue));

      if (chartInstances['drawdown-chart']) chartInstances['drawdown-chart'].destroy();
      const ctx = document.getElementById('drawdown-chart').getContext('2d');
      chartInstances['drawdown-chart'] = new Chart(ctx, {
        ...getChartConfig('line', {
          legend: { position: 'bottom', align: 'start' },
          yScale: {
            title: { display: true, text: 'Drawdown (%)', color: '#8899a6' },
            ticks: {
              color: '#8899a6',
              font: { size: 11 },
              callback: function(value) {
                return value.toFixed(2) + '%';
              }
            }
          }
        }),
        data: {
          labels: dates,
          datasets: [
            {
              label: 'Tracked Wallet Drawdown',
              data: trackedDrawdown,
              borderColor: '#667eea',
              backgroundColor: 'rgba(102, 126, 234, 0.3)',
              fill: true,
              borderWidth: 2,
              tension: 0.1,
              pointRadius: 0
            },
            {
              label: 'User Wallet Drawdown',
              data: userDrawdown,
              borderColor: '#17bf63',
              backgroundColor: 'rgba(23, 191, 99, 0.3)',
              fill: true,
              borderWidth: 2,
              tension: 0.1,
              pointRadius: 0
            }
          ]
        }
      });
    }

    function calculateDrawdown(accountValues) {
      const drawdowns = [];
      let runningMax = accountValues[0];

      for (let i = 0; i < accountValues.length; i++) {
        const value = accountValues[i];

        if (value > runningMax) {
          runningMax = value;
        }

        const drawdown = ((value - runningMax) / runningMax) * 100;
        drawdowns.push(drawdown);
      }

      return drawdowns;
    }

    function renderEntryDiffChart() {
      const coinData = {};

      filteredSnapshots.forEach(snapshot => {
        const timestamp = new Date(snapshot.timestamp);
        const trackedPositions = {};
        const userPositions = {};

        snapshot.tracked.positions.forEach(pos => {
          trackedPositions[pos.coin] = pos.entryPrice;
        });

        snapshot.user.positions.forEach(pos => {
          userPositions[pos.coin] = pos.entryPrice;
        });

        Object.keys(trackedPositions).forEach(coin => {
          if (userPositions[coin]) {
            if (!coinData[coin]) {
              coinData[coin] = { x: [], y: [] };
            }
            const diffPercent = ((userPositions[coin] - trackedPositions[coin]) / trackedPositions[coin]) * 100;
            coinData[coin].x.push(timestamp);
            coinData[coin].y.push(diffPercent);
          }
        });
      });

      const datasets = Object.entries(coinData).map(([coin, data]) => ({
        label: coin,
        data: data.x.map((x, i) => ({ x, y: data.y[i] })),
        borderColor: getSymbolColor(coin),
        backgroundColor: getSymbolColor(coin),
        borderWidth: 2,
        tension: 0.1,
        fill: false,
        pointRadius: 0
      }));

      if (chartInstances['entry-diff-chart']) chartInstances['entry-diff-chart'].destroy();
      const ctx = document.getElementById('entry-diff-chart').getContext('2d');
      chartInstances['entry-diff-chart'] = new Chart(ctx, {
        ...getChartConfig('line', {
          legend: { position: 'right' },
          yScale: {
            title: { display: true, text: 'Entry Price Difference (%)', color: '#8899a6' },
            ticks: {
              color: '#8899a6',
              font: { size: 11 },
              callback: function(value) {
                return value.toFixed(2) + '%';
              }
            }
          }
        }),
        data: { datasets }
      });
    }

    function renderRiskChart() {
      const dates = filteredSnapshots.map(s => new Date(s.timestamp));

      if (chartInstances['risk-chart']) chartInstances['risk-chart'].destroy();
      const ctx = document.getElementById('risk-chart').getContext('2d');
      chartInstances['risk-chart'] = new Chart(ctx, {
        ...getChartConfig('line', {
          legend: { position: 'top', align: 'start' },
          y2Scale: { title: { display: true, text: 'Margin Ratio (%)', color: '#8899a6' } }
        }),
        data: {
          labels: dates,
          datasets: [
            {
              label: 'Tracked Avg Leverage',
              data: filteredSnapshots.map(s => s.tracked.averageLeverage),
              borderColor: '#667eea',
              backgroundColor: 'rgba(102, 126, 234, 0.1)',
              borderWidth: 2,
              yAxisID: 'y',
              tension: 0.1,
              pointRadius: 0
            },
            {
              label: 'User Avg Leverage',
              data: filteredSnapshots.map(s => s.user.averageLeverage),
              borderColor: '#17bf63',
              backgroundColor: 'rgba(23, 191, 99, 0.1)',
              borderWidth: 2,
              yAxisID: 'y',
              tension: 0.1,
              pointRadius: 0
            },
            {
              label: 'Tracked Margin Ratio',
              data: filteredSnapshots.map(s => s.tracked.crossMarginRatio),
              borderColor: '#e0245e',
              backgroundColor: 'rgba(224, 36, 94, 0.1)',
              borderWidth: 2,
              borderDash: [5, 5],
              yAxisID: 'y2',
              tension: 0.1,
              pointRadius: 0
            },
            {
              label: 'User Margin Ratio',
              data: filteredSnapshots.map(s => s.user.crossMarginRatio),
              borderColor: '#ff6b9d',
              backgroundColor: 'rgba(255, 107, 157, 0.1)',
              borderWidth: 2,
              borderDash: [5, 5],
              yAxisID: 'y2',
              tension: 0.1,
              pointRadius: 0
            }
          ]
        }
      });
    }

    function showError(message) {
      document.getElementById('loading').style.display = 'none';
      document.getElementById('dashboard').style.display = 'none';
      document.getElementById('error').style.display = 'block';
      document.getElementById('error').textContent = message;
    }

    async function fetchHealthStatus() {
      try {
        const response = await fetch('/api/health');
        const healthData = await response.json();

        const statusBadge = document.getElementById('health-status-badge');
        statusBadge.textContent = healthData.status || 'Unknown';
        statusBadge.className = `health-status-badge ${healthData.status || 'unhealthy'}`;

        if (healthData.metrics) {
          const uptimeHours = Math.floor((healthData.metrics.uptime || 0) / 3600000);
          const uptimeMinutes = Math.floor(((healthData.metrics.uptime || 0) % 3600000) / 60000);
          document.getElementById('health-uptime').textContent = `${uptimeHours}h ${uptimeMinutes}m`;

          const orderSuccess = document.getElementById('health-order-success');
          const orderRate = healthData.metrics.orderSuccessRate || 0;
          orderSuccess.textContent = `${orderRate.toFixed(1)}%`;
          orderSuccess.className = `health-metric-value ${orderRate >= 80 ? 'healthy' : 'unhealthy'}`;

          const fillProcessing = document.getElementById('health-fill-processing');
          const fillRate = healthData.metrics.fillProcessingRate || 0;
          fillProcessing.textContent = `${fillRate.toFixed(1)}%`;
          fillProcessing.className = `health-metric-value ${fillRate >= 90 ? 'healthy' : 'unhealthy'}`;

          const errors = document.getElementById('health-errors');
          const errorCount = healthData.metrics.consecutiveErrors || 0;
          errors.textContent = errorCount.toString();
          errors.className = `health-metric-value ${errorCount === 0 ? 'healthy' : 'unhealthy'}`;
        }

        if (healthData.checks) {
          const websocket = document.getElementById('health-websocket');
          const wsHealthy = healthData.checks.websocket?.healthy || false;
          websocket.textContent = wsHealthy ? 'Connected' : 'Disconnected';
          websocket.className = `health-metric-value ${wsHealthy ? 'healthy' : 'unhealthy'}`;

          const api = document.getElementById('health-api');
          const apiHealthy = healthData.checks.api?.healthy || false;
          api.textContent = apiHealthy ? 'Healthy' : 'Degraded';
          api.className = `health-metric-value ${apiHealthy ? 'healthy' : 'unhealthy'}`;
        }
      } catch (error) {
        console.error('Error fetching health status:', error);
      }
    }

    async function fetchIncidents() {
      try {
        const response = await fetch('/api/health/incidents?days=1');
        const data = await response.json();

        renderIncidentsChart(data.incidents || []);
      } catch (error) {
        console.error('Error fetching incidents:', error);
      }
    }

    function renderIncidentsChart(incidents) {
      if (chartInstances['incidents-chart']) chartInstances['incidents-chart'].destroy();

      const severityColors = {
        warning: '#ffad1f',
        error: '#e0245e',
        critical: '#ff0044'
      };

      const typeLabels = {
        websocket: 'WebSocket',
        api: 'API',
        orderFailure: 'Order Failure',
        fillError: 'Fill Error',
        balanceRatio: 'Balance Ratio',
        tradingPaused: 'Trading Paused'
      };

      const incidentPoints = incidents
        .filter(inc => !inc.resolved)
        .map(inc => ({
          x: new Date(inc.timestamp),
          y: inc.severity === 'critical' ? 3 : inc.severity === 'error' ? 2 : 1,
          incident: inc
        }));

      const ctx = document.getElementById('incidents-chart').getContext('2d');
      chartInstances['incidents-chart'] = new Chart(ctx, {
        type: 'scatter',
        data: {
          datasets: [{
            label: 'Incidents',
            data: incidentPoints,
            backgroundColor: incidentPoints.map(p => severityColors[p.incident.severity]),
            borderColor: incidentPoints.map(p => severityColors[p.incident.severity]),
            borderWidth: 2,
            pointRadius: 8,
            pointHoverRadius: 12
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            tooltip: {
              backgroundColor: '#192734',
              titleColor: '#e1e8ed',
              bodyColor: '#8899a6',
              borderColor: '#38444d',
              borderWidth: 1,
              callbacks: {
                label: function(context) {
                  const incident = context.raw.incident;
                  return [
                    `Type: ${typeLabels[incident.type] || incident.type}`,
                    `Severity: ${incident.severity}`,
                    `Message: ${incident.message}`,
                    `Time: ${new Date(incident.timestamp).toLocaleString()}`
                  ];
                }
              }
            }
          },
          scales: {
            x: {
              type: 'time',
              time: {
                tooltipFormat: 'MMM d, HH:mm',
                displayFormats: {
                  hour: 'HH:mm',
                  minute: 'HH:mm'
                }
              },
              ticks: { color: '#8899a6', font: { size: 11 } },
              grid: { color: '#38444d' },
              title: { display: true, text: 'Time', color: '#8899a6' }
            },
            y: {
              min: 0,
              max: 4,
              ticks: {
                color: '#8899a6',
                font: { size: 11 },
                stepSize: 1,
                callback: function(value) {
                  const labels = ['', 'Warning', 'Error', 'Critical'];
                  return labels[value] || '';
                }
              },
              grid: { color: '#38444d' },
              title: { display: true, text: 'Severity', color: '#8899a6' }
            }
          }
        }
      });

      if (incidents.length === 0) {
        ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
        ctx.fillStyle = '#8899a6';
        ctx.textAlign = 'center';
        ctx.fillText('No incidents in the last 24 hours', ctx.canvas.width / 2, ctx.canvas.height / 2);
      }
    }

    fetchSnapshots();
    fetchHealthStatus();
    fetchIncidents();

    setInterval(() => {
      fetchSnapshots();
    }, 60000);

    setInterval(() => {
      fetchHealthStatus();
      fetchIncidents();
    }, 30000);
  </script>
</body>
</html>
